import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';

import { Users } from './model';

import {
    createAccessToken,
    createActivationToken,
    createRefreshToken,
    createResetPasswordToken,
} from '../../utils/generateToken';

import { validateEmail } from '../../utils/valid';
import {
    sendActivationMail,
    sendResetPasswordEmail,
} from '../../utils/sendMail';
import { generatePassword } from '../../utils/generatePassword';
import { checkAuth } from '../../middleware/auth';

import { UserInterface } from './interfaces';
import { Games } from '../game/model';
import { GameInterface } from '../game/interfaces';

export const userCtrl = {
    register: async (req: any, res: any) => {
        try {
            const { name, email, password, role } = req.body;

            let reqUser: UserInterface | null = null;

            if (!name || !email) {
                return res.status(400).json({ err: 'fill-fields' });
            }

            let securePassword = password;
            let autoGeneratedPassword = false;

            if (!password) {
                securePassword = generatePassword();
                autoGeneratedPassword = true;
            }

            if (!validateEmail(email)) {
                return res.status(400).json({ err: 'wrong-email-format' });
            }

            if (securePassword.length < 6) {
                return res.status(400).json({ err: 'password-too-short' });
            }

            const emailCheck = await Users.findOne({ email: email });
            if (emailCheck) {
                return res.status(400).json({ err: 'email-taken' });
            }

            const passwordHash = await bcrypt.hash(securePassword, 12);

            if (role && role >= 1) {
                reqUser = await checkAuth(req, res);

                if (!reqUser || reqUser.role < role) {
                    return res.status(400).json({
                        err: 'cant-create-other-admins',
                    });
                }
            }

            const newUser = {
                name: name,
                email: email,
                role: role,
                password: passwordHash,
            };

            const activation_token = createActivationToken(newUser);
            if (!activation_token) {
                return res.status(500).json({ err: 'activation-failed' });
            }

            const sent = await sendActivationMail(
                name,
                email,
                securePassword,
                activation_token,
                autoGeneratedPassword
            );
            if (!sent) {
                return res.status(500).json({ err: 'activation-email-failed' });
            }

            res.json({ msg: 'Autorizācijas e-pasts nosūtīts!' });
        } catch (err: any) {
            return res.status(500).json({ err: err.message });
        }
    },
    activate: async (req: any, res: any) => {
        try {
            const { name, email, password, role } = req.user;

            if (!validateEmail(email)) {
                return res.status(400).json({ err: 'wrong-email-format' });
            }

            const emailCheck = await Users.findOne({ email: email });
            if (emailCheck) {
                return res.status(400).json({ msg: 'email-taken' });
            }

            const new_user = new Users({
                name: name,
                role: role,
                email: email,
                password: password,
            });

            await new_user.save();

            const access_token = createAccessToken({
                _id: new_user._id,
            });

            res.cookie('accesstoken', access_token, {
                path: process.env.NODE_ENV === 'production' ? '/' : undefined,
                domain:
                    process.env.NODE_ENV === 'production'
                        ? process.env.COOKIE_DOMAIN
                        : undefined,
                secure:
                    process.env.NODE_ENV === 'production' ? true : undefined,
                httpOnly: process.env.NODE_ENV === 'production' ? true : false,
                sameSite:
                    process.env.NODE_ENV === 'production' ? 'none' : undefined,
                maxAge: 3 * 24 * 60 * 60 * 1000,
            });

            res.json({
                msg: 'Konts aktivizēts!',
                user: new_user,
                access_token: access_token,
            });
        } catch (err: any) {
            return res.status(500).json({ err: err.message });
        }
    },
    login: async (req: any, res: any) => {
        try {
            const { email, password } = req.body;

            if (!validateEmail(email)) {
                return res.status(400).json({ err: 'wrong-email-format' });
            }

            if (!email || !password) {
                return res.status(400).json({ err: 'fill-fields' });
            }

            const user = await Users.findOne({ email: email });
            if (!user) {
                return res.status(400).json({ err: 'email-not-exist' });
            }

            const isMatch = await bcrypt.compare(password, user.password);
            if (!isMatch) {
                return res.status(400).json({ err: 'wrong-password' });
            }

            const refresh_token = createRefreshToken({ _id: user._id });

            res.cookie('refreshtoken', refresh_token, {
                path: process.env.NODE_ENV === 'production' ? '/' : undefined,
                domain:
                    process.env.NODE_ENV === 'production'
                        ? process.env.COOKIE_DOMAIN
                        : undefined,
                secure:
                    process.env.NODE_ENV === 'production' ? true : undefined,
                httpOnly: process.env.NODE_ENV === 'production' ? true : false,
                sameSite:
                    process.env.NODE_ENV === 'production' ? 'none' : undefined,
                maxAge: 3 * 24 * 60 * 60 * 1000,
            });

            res.json({
                msg: 'Veiksmīgi pieslēdzāties!',
                refresh_token: refresh_token,
            });
        } catch (err: any) {
            return res.status(500).json({ err: err.message });
        }
    },
    getAccessToken: async (req: any, res: any) => {
        try {
            const rf_token_secret: string | undefined =
                process.env.REFRESH_TOKEN_SECRET;
            if (!rf_token_secret) {
                return res.status(400).json({ err: 'error' });
            }

            const refreshtoken = req.query.token //const { refreshtoken } = req.cookies;
            if (!refreshtoken) {
                return res.status(400).json({ err: 'plelase-log-in' });
            }

            const result: any = jwt.verify(refreshtoken, rf_token_secret, {
                ignoreExpiration: true,
            });
            if (!result) {
                return res.status(400).json({ err: 'plelase-log-in' });
            }

            const user = await Users.findById(result._id).select('-password');
            if (!user) {
                return res.status(400).json({ err: 'user-not-exist' });
            }

            let userGame: null | GameInterface = null;

            if (user.role >= 1) {
                userGame = await Games.findOne({ admin: user._id });
            }

            const access_token = createAccessToken({ _id: user._id });

            res.cookie('accesstoken', access_token, {
                path: process.env.NODE_ENV === 'production' ? '/' : undefined,
                domain:
                    process.env.NODE_ENV === 'production'
                        ? process.env.COOKIE_DOMAIN
                        : undefined,
                secure:
                    process.env.NODE_ENV === 'production' ? true : undefined,
                httpOnly: process.env.NODE_ENV === 'production' ? true : false,
                sameSite:
                    process.env.NODE_ENV === 'production' ? 'none' : undefined,
                maxAge: 3 * 24 * 60 * 60 * 1000,
            });

            res.json({
                access_token,
                user,
                game: userGame,
            });
        } catch (err: any) {
            return res.status(500).json({ err: err.message });
        }
    },
    getAllUsers: async (req: any, res: any) => {
        try {
            const authAdmin = req.user;

            if (authAdmin.role < 2) {
                return res.status(400).json({ msg: 'cant-access-users' });
            }

            const users = await Users.find().select('-password');

            res.json(users);
        } catch (err: any) {
            return res.status(500).json({ err: err.message });
        }
    },
    getAllAdmins: async (req: any, res: any) => {
        try {
            const authAdmin = req.user;

            if (authAdmin.role < 2) {
                return res.status(400).json({ msg: 'cant-access-users' });
            }
            const users = await Users.find({ role: { $in: [1, 2] } }).select('-password');

            res.json(users);
        } catch (err: any) {
            return res.status(500).json({ err: err.message });
        }
    },
    getOne: async (req: any, res: any) => {
        try {
            const { id } = req.params;

            const user = await Users.findById({ _id: id }).select('-password');
            if (!user) {
                return res.status(400).json({ msg: 'user-not-exist' });
            }

            res.json(user);
        } catch (err: any) {
            return res.status(500).json({ err: err.message });
        }
    },
    logout: async (req: any, res: any) => {
        try {
            res.clearCookie('refreshtoken', { path: '/' });

            return res.json({ msg: 'Izrakstījāties' });
        } catch (err: any) {
            return res.status(500).json({ err: err.message });
        }
    },
    updateUser: async (req: any, res: any) => {
        try {
            const { name, email, password, profile_picture } = req.body;

            if (email) {
                if (!validateEmail(email)) {
                    return res.status(400).json({ err: 'wrong-email-format' });
                }
            }

            const authUser = req.user;

            await authUser.updateOne({
                name,
                email,
                password,
                profile_picture,
            });

            res.json({ msg: 'Konts veiksmīgi atjaunots' });
        } catch (err: any) {
            return res.status(500).json({ err: err.message });
        }
    },
    forgotPassword: async (req: any, res: any) => {
        try {
            const { email } = req.body;

            const user = await Users.findOne({ email: email });

            if (!user) {
                return res.status(400).json({ err: 'email-not-exist' });
            }

            const resetPasswordToken = createResetPasswordToken({
                _id: user._id,
            });

            if (!resetPasswordToken) {
                return res.status(500).json({
                    err: 'password-token-fail',
                });
            }

            const sent = await sendResetPasswordEmail(
                user.name,
                email,
                resetPasswordToken
            );
            if (!sent) {
                return res.status(500).json({
                    err: 'password-email-fail',
                });
            }

            res.json({ msg: 'Paroles atjaunošans e-pasts tika nosūtīts!' });
        } catch (err: any) {
            return res.status(500).json({ err: err.message });
        }
    },
    resetPassword: async (req: any, res: any) => {
        try {
            const authUser = req.user;
            const { password } = req.body;

            if (!authUser) {
                return res.status(400).json({
                    err: 'user-not-exist',
                });
            }

            if (password.length < 6) {
                return res.status(400).json({ err: 'password-too-short' });
            }

            const passwordHash = await bcrypt.hash(password, 12);

            await authUser.updateOne({
                password: passwordHash,
            });

            res.json({ msg: 'Parole tika veiksmīgi atjaunota!' });
        } catch (err: any) {
            return res.status(500).json({ err: err.message });
        }
    },
    deleteUser: async (req: any, res: any) => {
        try {
            const userId = req.params.id;
            if (!userId) {
                return res.status(500).json({ err: 'error' });
            }

            await Users.findByIdAndDelete(userId);

            res.json({ msg: 'Lietotāja profils dzēsts!' });
        } catch (err: any) {
            return res.status(500).json({ err: err.message });
        }
    },
    deleteAccount: async (req: any, res: any) => {
        try {
            const userId = req.user._id.toString();

            await Users.findByIdAndDelete(userId);

            res.json({ msg: 'Konts dzēsts!' });
        } catch (err: any) {
            return res.status(500).json({ err: err.message });
        }
    },
};
